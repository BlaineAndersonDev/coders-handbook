# =====================================================================
# Recursive Understanding Practice:
  # The base idea of how recursion works in function form:
      #if ___ == 1:
        #Perform Action Completion: Print/Append/Etc...
      #else:
        #Perform Action Division: Length of list / 2: Assign variables for each half.
        #Recall Self Function using new variables
  # A practical example: (With print statements available)

# =====================================================================
# https://projecteuler.net/problem=1
# If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.

# [3, 5, 6, 9] = 23
# [1...1000] = ?

# Iterate over a list of numbers
def sum_of_multiples(list_size, mul_a, mul_b):
  complete_list = range(1, (list_size + 1))
# Find all multiples of 3. Add those up.
  mul_a_total = get_multiples(complete_list, mul_a)
  # Find all multiples of 5. Add those Up.
  mul_b_total = get_multiples(complete_list, mul_b)
  # Combine multiples of 3 and multiples of 5 totals into one total.
  total = mul_a_total + mul_b_total
  # return total.
  return total

def get_multiples(lst, mul):
  mul_lst = [num for num in lst if num % mul == 0]
  mul_total = 0
  for num in mul_lst:
    mul_total += num
  return mul_total

# Uncomment line below to run code:
# print(sum_of_multiples(9, 3, 5))
# =====================================================================
# https://projecteuler.net/problem=2
# Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

#Use parameter to find the nth numbers in the sequence.
# Place all those numbers in a list
# Remove all odd numbers from list.
# combine all numbers into one total.
# return total

def fib_even_sum(num):
  sequence_list = generate_fib_list(num)
  even_sequence_list = [num for num in sequence_list if num % 2 == 0]
  even_total = 0
  for num in even_sequence_list:
    even_total += num
  return even_total

def generate_fib_list(num):
  i = 0
  a = 0
  b = 1
  c = 0
  fib_values = []
  while i < num:
    c = a + b
    a = b
    b = c
    fib_values.append(c)
    i += 1
  return fib_values

# print(fib_even_sum(50))


# def fib_sequence(num):
#   if num == 1 or num == 2:
#     print("IF: num is: " + str(num))
#     return 1
#   else:
#     print("ELSE: num is: " + str(num))
#     return fib_sequence(num - 1) + fib_sequence(num - 1)
#
# print(fib_sequence(10))



# =====================================================================
# John works at a clothing store. He has a large pile of socks that he must pair by color for sale. Given an array of integers representing the color of each sock, determine how many pairs of socks with matching colors there are.
# For example, there are n = 7 socks with colors arr = [1,2,1,2,1,3,2]. There is one pair of color 1 and one of color 2 . There are three odd socks left, one of each color. The number of pairs is 2.



# =====================================================================



# =====================================================================

characters = ["Eric", "Kenny", "Kyle", "Stan", "Butters", "Wendy", "Token", "Clyde", "Tweek", "Coon", "Randy", "Shelia"]
def characters_find_chinpokemon(characters):
  if len(characters) == 1:
    print(characters[0] + " found a chinpokemon!")
  else:
    center = len(characters) / 2
    # print("center index: " + str(center) + ". Center Char: " + characters[center])
    front_half = characters[:center]
    # print("front_half: " + str(front_half))
    back_half = characters[center:]
    # print("back_half: " + str(back_half))
    characters_find_chinpokemon(front_half)
    characters_find_chinpokemon(back_half)
# Uncomment line below to run code:
# characters_find_chinpokemon(characters)


# Function "characters_find_chinpokemon" breakdown:
  # The Characters list has 12 names in it:
  # The Print statement only runs if there is ONE character in the given list.
  # Until there is only ONE character it will take the list of characters and find the center point, divide it into two lists, and RERUN the function using those new lists:
    # Run 1:
      # center index: 6. Center Char: Token
      # front_half: ['Eric', 'Kenny', 'Kyle', 'Stan', 'Butters', 'Wendy']
      # back_half: ['Token', 'Clyde', 'Tweek', 'Coon', 'Randy', 'Shelia']
    # Run 2 (Run 1 Front Half):
      # center index: 3. Center Char: Stan
      # front_half: ['Eric', 'Kenny', 'Kyle']
      # back_half: ['Stan', 'Butters', 'Wendy']
    # Run 3 (Run 2 Front Half)
      # center index: 1. Center Char: Kenny
      # front_half: ['Eric']
      # back_half: ['Kenny', 'Kyle']
    # Run 4 (Run 3 Front Half) - ONE character run, it performs the print action.
      # Eric found a chinpokemon!
    # Run 5 (Run 3 Back End)
      # center index: 1. Center Char: Kyle
      # front_half: ['Kenny']
      # back_half: ['Kyle']
    # Run 6 (Run 5 Front Half) - ONE character run, it performs the print action.
      # Kenny found a chinpokemon!
    # Run 7 (Run 5 Back Half) - ONE character run, it performs the print action.
      # Kyle found a chinpokemon!
    # Run 8 (Run 2 Back End)
      # center index: 1. Center Char: Butters
      # front_half: ['Stan']
      # back_half: ['Butters', 'Wendy']
    # Run 9 (Run 8 Front Half) - ONE character run, it performs the print action.
      # Stan found a chinpokemon!
    # Run 9 (Run 8 Back Half)
      # center index: 1. Center Char: Wendy
      # front_half: ['Butters']
      # back_half: ['Wendy']
    # Run 10 (Run 9 Front Half) - ONE character run, it performs the print action.
      # Butters found a chinpokemon!
    # Run 11 (Run 9 Back Half) - ONE character run, it performs the print action.
      # Wendy found a chinpokemon!
    # Run 12 (Run 1 Back End)
      # center index: 3. Center Char: Coon
      # front_half: ['Token', 'Clyde', 'Tweek']
      # back_half: ['Coon', 'Randy', 'Shelia']
    # Run 13 (Run 12 Front End)
      # center index: 1. Center Char: Clyde
      # front_half: ['Token']
      # back_half: ['Clyde', 'Tweek']
    # Run 14 (Run 13 Front Half) - ONE character run, it performs the print action.
      # Token found a chinpokemon!
    # Run 15 (Run 13 Back End)
      # center index: 1. Center Char: Tweek
      # front_half: ['Clyde']
      # back_half: ['Tweek']
    # Run 16 (Run 15 Front Half) - ONE character run, it performs the print action.
      # Clyde found a chinpokemon!
    # Run 17 (Run 15 Back Half) - ONE character run, it performs the print action.
      # Tweek found a chinpokemon!
    # Run 18 (Run 12 Back End)
      # center index: 1. Center Char: Randy
      # front_half: ['Coon']
      # back_half: ['Randy', 'Shelia']
    # Run 19 (Run 18 Front Half) - ONE character run, it performs the print action.
      # Coon found a chinpokemon!
    # Run 20 (Run 18 Back Half)
      # center index: 1. Center Char: Shelia
      # front_half: ['Randy']
      # back_half: ['Shelia']
    # Run 21 (Run 20 Front Half) - ONE character run, it performs the print action.
      # Randy found a chinpokemon!
    # Run 22 (Run 20 Back Half) - ONE character run, it performs the print action.
      # Shelia found a chinpokemon!

# ------------------------
# Fibonacci Recursion:
  # The Fibonacci Sequence is essentially
    # A + B = C
    # A = B
    # B = C
    # Repeat to the n'th time.

# def fibonacci_sequence(num_times, a=0, b=1):
#     print("Sequence a: " + str(a) + ", b: " + str(b))
#     c = 0
#     if b >= num_times:
#       print("END SEQUENCE")
#     else:
#       c = a + b
#       a = b
#       b = c
#       fibonacci_sequence(num_times, a, b)
# Uncomment line below to run code:
# fibonacci_sequence(14)
# ------------------------

def fibonacci(n):
  if n == 1 or n == 2:
    print("IF: n is: " + str(n))
    return 1
  else:
    print("ELSE: n is: " + str(n))
    return (fibonacci(n - 1) + (fibonacci(n - 2)))

# print(fibonacci(7))
# If we use 5 as the original number:
# 5
# 4 | 3
# 3 | 1

# EXAMPLE:
# def fibonacci(n):
#   if n == 1 or n == 2:
#     return 1
#   else:
#     return (fibonacci(n - 1) + (fibonacci(n - 2)))
#
# print(fibonacci(7))
# ------------------------

def list_sum(num_list):
  if len(num_list) == 1:
    return num_list[0]
  else:
    return num_list[0] + list_sum(num_list[1:])

# print(list_sum([2, 4, 5, 6, 7]))

# EXAMPLE:
# def list_sum(num_list):
#     if len(num_list) == 1:
#         return num_list[0]
#     else:
#         return num_list[0] + list_sum(num_list[1:])
#
# print(list_sum([2, 4, 5, 6, 7]))
# ------------------------
# A factorial is a number * itself the given number of times

def factorial(n):
  if n <= 1:
    return 1
  else:
    return n *(factorial(n-1))

# print(factorial(5))

# EXAMPLE:
# def factorial(n):
#   if n <= 1:
#     return 1
#   else:
#     return n * (factorial(n - 1))
#
# print(factorial(5))

# ------------------------
# 1 1 0 0
# 0 1 1 0
# 0 0 1 0
# 1 0 0 0
# Check each number until we find a 1
# Upon finding a 1, begin searching every adjacent square for 1's
# If a 1 is found, repeat process on new one.
# track and return largest 'region' or set of connected 1's

# grid = [[1,1,0,0],[0,1,1,0],[0,0,1,0],[1,0,0,0]]
# def return_largest_region(grid):
#   # Check every number:
#   for lst in grid:
#     print(lst)
#     for cell in lst:
#       lst_i = grid.index(lst)
#       cell_i = lst.index(cell)
#       if check_neighbors(lst_i, cell_i) == True:
#       # RUN NEW FUNCTION:
#
#
#       if cell == 1:
#         print("true ")# return True if its a 1
#         check_neighbors(cell)
#         if True:
#           # Run check_neighbors on new cell
#           print("IT WAS TRUE")
#         else:
#           continue
#       else:
#         print("false") # return False if its a 0
#
# def check_neighbors(lst_i, cell_i):
#   print(cell)
#
#
# print(return_largest_region(grid))

#
# def find_region(grid, lst_i=0, cell_i=0, count=0, final_count=0):
#   print("Current Count: " + str(count) + " - Final Count: " + str(final_count))
#
#   for lst in grid:
#     print("Current List: " + str(lst))
#     for cell in lst:
#       print("Current Cell: " + str(cell))
#       if check_nearby(grid, lst_i, cell_i) == True:
#       else: # False
#
#   if grid[lst_i][cell_i] == 1:  # If current location is a 1
#     grid[lst_i][cell_i] = 0 # Set current location to 0 to prevent double counting.
#     count += 1 # Add 1 to the count each time a 1 is found connected.
#     print("Calling check nearby on: " + str(lst_i) + " - " + str(cell_i))
#     check_nearby(grid, lst_i, cell_i, count, final_count)
#   else:
#     if count > final_count:
#       final_count = count
#   return final_count
#
# def check_nearby(grid, lst_i, cell_i, count, final_count):
#   print("Check Nearby: " + str(lst_i) + " - " + str(cell_i))
#   if grid[lst_i-1][cell_i-1] == 1 and lst_i != 0 and cell_i != 0:  #Top left
#     find_region(grid, (lst_i-1), (cell_i-1), count, final_count)
#   elif grid[lst_i-1][cell_i] == 1 and lst_i != 0:    #Top Above
#     find_region(grid, (lst_i-1), (cell_i), count, final_count)
#   elif grid[lst_i-1][cell_i+1] == 1 and lst_i != 0 and cell_i != -1:  #Top Right
#     find_region(grid, (lst_i-1), (cell_i+1), count, final_count)
#   elif grid[lst_i][cell_i-1] == 1 and cell_i != 0:    #Same Left
#     find_region(grid, (lst_i), (cell_i-1), count, final_count)
#   elif grid[lst_i][cell_i+1] == 1 and cell_i != -1:    #Same Right
#     return True
#     # find_region(grid, (lst_i), (cell_i+1), count, final_count)
#   elif grid[lst_i+1][cell_i-1] == 1 and lst_i != -1 and cell_i != 0:  #Bottom left
#     find_region(grid, (lst_i+1), (cell_i-1), count, final_count)
#   elif grid[lst_i+1][cell_i] == 1 and lst_i != -1:    #Bottom Below
#     find_region(grid, (lst_i+1), (cell_i), count, final_count)
#   elif grid[lst_i+1][cell_i+1] == 1 and lst_i != -1 and cell_i != -1:  #Bottom Right
#     find_region(grid, (lst_i+1), (cell_i+1), count, final_count)
#
# the_count = find_region(grid)
# print(str(the_count))

# I've added a default list index and cell index. These can be altered later as re use recursion to recall the function.

# =====================================================================
# Smallest Substring of All Characters
# Given an array of unique characters arr and a string str, Implement a function getShortestUniqueSubstring that finds the smallest substring of str containing all the characters in arr.
# Return "" if such a substring doesnt exist.
#
# Come up with an asymptotically optimal solution and analyze the time and space complexities.
# ------------------------
# Uncomment below to use:
# ------------------------
# def get_shortest_unique_substring(arr, str):
#   split_str = str.split() # Simplfy str into single letters
#   return_array = [] # Create return_array list.
#   for item in arr:
#     if item in str: # Then compare item to str for matches.
#       if item in return_array: # Check if already in return array
#         continue
#       else:
#         return_array.append(item) # Add to new array
#   if len(return_array) == 0:
#     return ""
#   elif len(return_array) == 1:
#     return_string = return_array[0]
#     return return_string
#   else:
#     return_string = ''.join(return_array)
#     return return_string


# Find and return the smallest substring which includes all the required characters in any order.
# Iterate over the chacters until a match is found
# Then it should iterate from that index until it has a complete match.
# The match should be compared to the current match and if shorter, it is kept.
# Once all top-level iterations are complete, return the match
            #
            # def get_shortest_unique_substring(arr, str, substring=""):
            #   i = 0
            #   #Compare str with arr. Remove all items in arr that do not exist in str.
            #   arr = cleanup_arr(str, arr)
            #   for i in range(0, len(str)):
            #     new_substring = recursive_checking(str[i:], arr, substring)
            #     if len(new_substring) >= len(substring):
            #       substring = new_substring
            #   return substring
            #
            # def recursive_checking(sm_str, arr, substring):
            #   #if ___ == 1:
            #   if all_items_included(arr, substring) == True:
            #     #Check if end chars and one inside are same. If so remove end piece.
            #
            #     #Perform Action Completion: Print/Append/Etc...
            #     return substring
            #   #else:
            #   else:
            #     new_substring = substring + sm_str[0]
            #     return new_substring
            #     #Perform Action Division: Length of list / 2: Assign variables for each half.
            #     #Recall Self Function using new variables
            #
            # def all_items_included(arr, substring):
            #   count = 0
            #   check_against = ''.join(arr)
            #   for item in arr:
            #     if item in substring:
            #       if item in check_against:
            #         continue
            #       else:
            #         count += 1
            #   if count == len(arr):
            #     return True
            #   else:
            #     return False
            #
            # def cleanup_arr(str, arr):
            #   for i in range(0, len(arr)):
            #     if arr[i] in str:
            #       continue
            #     else:
            #       del arr[i]
            #   return arr

def get_shortest_unique_substring(arr, str, substring="", final_substring=""):
  # Removes any items in arr that do not exist in str.
  clean_arr = [item for item in arr if item in str]

  # Check current substring to see if all the letters in the arr are in the substring.
  for char in str:
    substring += char
    if all_items_accounted_for(arr, substring) == True:
      if len(substring) < len(final_substring) or len(final_substring) == 0:
        final_substring = substring
  if len(final_substring) >= 1:
    return final_substring
  else:
    return ("No String: " + final_substring)

def all_items_accounted_for(arr, substring):
  # if all items in arr are presetn in substring return substring.
  count = 0
  for item in arr:
    if item in substring:
      count += 1
    else:
      continue
  if count == len(arr):
    # print("count: " + substring(count))
    return True
  else:
    return False

  # else recall loop with +1 index

# print(get_shortest_unique_substring(["A","B","C"], "ADOBECODEBANCDDD"))
#   #=> "BANC"
# print(get_shortest_unique_substring(['x','y','z'], "xyyzyzyx"))
#   #=> xyz
# print(get_shortest_unique_substring(['y','z','a'], "xyyzyzyx"))
#   #=> yz
# print(get_shortest_unique_substring(['a'], "xyyzyzyx"))
#   #=> ""
# print(get_shortest_unique_substring(["A"], ""))
#   #=> ""
# print(get_shortest_unique_substring(["A"], "B"))
#   #=> ""
# print(get_shortest_unique_substring(["A"], "A"))
#   #=> A
# print(get_shortest_unique_substring(["A","B","C","E","K","I"], "KADOBECODEBANCDDDEI"))
#   #=> "KADOBECODEBANCDDDEI"

# =====================================================================
# def ransom_note_possible(ransom_words, magazine_words):
#   for r_word in ransom_words:
#     if r_word in magazine_words:
#       continue
#     else:
#       return False
#   return True
#

# Check if the ransom note can be pasted together using words only from the magazine.
def ransom_note_possible(ransom_words, magazine_words):
  oolong = {}
  for m_word in magazine_words:
    if m_word in oolong:
      oolong[m_word] += 1
    else:
      oolong[m_word] = 1
  print(oolong)
  for i in range(0, len(ransom_words)):
    if ransom_words[i] in oolong and oolong[ransom_words[i]] > 0:
      print(ransom_words[i])
      oolong[ransom_words[i]] -= 1
      print(oolong)
    else:
      return False
  return True

# print(ransom_note_possible(["give", "give", "one", "grand", "today"], ["give", "me", "one", "grand", "today", "night", "give"]))
# print(ransom_note_possible(["give", "give", "one", "grand", "today"], ["give", "me", "one", "grand", "today", "night"]))
#print(ransom_note_possible(["Give", "one", "GrAnD", "today"], ["give", "me", "One", "grand", "toDAY", "night"]))

#  for r_word in ransom_words:
#    for m_word in magazine_words:
#      if r_word == m_word:
#        del magazine_words[magazine_words.index(m_word)]
#        count += 1
#      else:
#        continue
# =====================================================================
# Given an array arr of distinct integers and a nonnegative integer k, write a function findPairsWithGivenDifference that returns an array of all pairs [x,y] in arr, such that x - y = k.
# If no such pairs exist, return an empty array.
# Note: the order of the pairs in the output array should maintain the order of the y element in the original array
# ------------------------
# Uncomment below to use:
# ------------------------
def find_pairs_with_given_difference(arr, k):
  # Iterate over each number, and then one number past it (x, x-1)
  pairs = []
  i = 0
  if arr[-1] - arr[0] == k:
    pairs.append([arr[-1], arr[0]])
  for i in range(0, (len(arr) - 1)):
    if i == 0 and arr[i+1] - arr[i] == k:
      pairs.append([arr[i+1], arr[i]])
    elif arr[i+1] - arr[i] == k:
      pairs.append([arr[i+1], arr[i]])
    i += 1
  i = 0
  for i in range(0, (len(arr) - 1)):
    if i == 0 and arr[i] - arr[i+1] == k:
      pairs.append([arr[i], arr[i+1]])
    elif arr[i] - arr[i+1] == k:
      pairs.append([arr[i], arr[i+1]])
    i += 1
  return pairs
#
# print(find_pairs_with_given_difference([0, -1, -2, 2, 1], 1))
#   #=> [[1, 0], [0, -1], [-1, -2], [2, 1]]
# print(find_pairs_with_given_difference([1, 7, 5, 3, 32, 17, 12], 17))
#   #=> []
# print(find_pairs_with_given_difference([4,1], 3))
# #  #=> [[4,1]]
# print(find_pairs_with_given_difference([1,5,11,7], 4))
# #  # => [[5,1],[11,7]]
# print(find_pairs_with_given_difference([1,5,11,7], 6))
# #  #=> [[5, 1], [11, 7]]
# print(find_pairs_with_given_difference([1,7,5,3,32,17,12], 17))
# #  #=> []
# =====================================================================
#
# Write a function that takes in the image and returns the coordinates of the rectangle of 0's -- either top-left and bottom-right; or top-left, width, and height.

# Sample output:
# x: 3, y: 2, width: 3, height: 2
# 2,3 3,5
# 3,2 5,3 -- it's ok to reverse columns/rows as long as you're consistent
# ------------------------
# Uncomment below to use:
# ------------------------
#
image = [
  [1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 0, 0, 0, 1],
  [1, 1, 1, 0, 0, 0, 1],
  [1, 1, 1, 1, 1, 1, 1],
]

def find_white_box(grid):
    first_location = {}
    last_location = {}
    for row_i in range(len(grid)):
        # print(row_i)
        for cell_i in range(len(grid[row_i])):
            # print(cell_i)
            if grid[row_i][cell_i] == 0:
                if first_location == {}:
                    first_location = {"row":row_i, "cell":cell_i}
                    # print("First: " + str(first_location))
                else:
                    last_location["row"] = row_i
                    last_location["cell"] = cell_i
                    # print("Last: " + str(last_location))
            else:
                continue
                # print("NOPE")
    return first_location, last_location

# print(find_white_box(image))
#=> ({'cell': 3, 'row': 2}, {'cell': 5, 'row': 3})

# =====================================================================
# Given an array of integers arr where each element is at most k places away from its sorted position, code an efficient function sortKMessedArray that sorts arr. For instance, for an input array of size 10 and k = 2, an element belonging to index 6 in the sorted array will be located at either index 4, 5, 6, 7 or 8 in the input array.
# input:  arr = [1, 4, 5, 2, 3, 7, 8, 6, 10, 9], k = 2
#
# output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# ------------------------
# Sort by value the arr

def sort_by_value(arr, k):
  sorted_arr = []
  while len(arr) > 0:
    current_index = arr.index(min(arr))
    # print(current_index)
    sorted_arr = sorted_arr + [min(arr)]
    del arr[current_index]
  return sorted_arr

# print(sort_by_value([1, 4, 5, 2, 3, 7, 7, 8, 6, 10, 9], 2))

# =====================================================================
# Find the smallest number:
# ------------------------

def find_smallest_number(number_list):
  smallest_num = number_list[0]
  for num in number_list:
    if num < smallest_num:
      smallest_num = num
    else:
      continue
  return smallest_num

# print(find_smallest_number([4, 5, 2, 3, 7, 7, 8, 6, 10, 1, 9]))
# ------------------------
def sort_by_value_2(arr, k):
  sorted_arr = [arr[arr.index(find_smallest_number(arr))]]
  del arr[arr.index(find_smallest_number(arr))]
  while len(arr) > 0:
    sorted_arr = sorted_arr + [arr[arr.index(find_smallest_number(arr))]]
    del arr[arr.index(find_smallest_number(arr))]
  return sorted_arr


# print(sort_by_value_2([1, 4, 5, 2, 3, 7, 7, 8, 6, 10, 9], 2))

# =====================================================================
# Prctice for Interview:
# Sort the array in order smallest to largest
# Return sorted array.

def sort_small_to_large(array):
  find_and_remove_words(array)
  smallest_num = array[0]
  sorted_arr = []
  while len(array) > 0:
    smallest_num_i = array.index(min(array))
    sorted_arr = sorted_arr + [min(array)]
    del array[smallest_num_i]
  return sorted_arr

def find_and_remove_words(arr):
  i_to_remove = []
  for i in range(0, len(arr)):
    if isinstance(arr[i], int):
      continue
    else:
      i_to_remove = [i] + i_to_remove
  for i in range(0, len(i_to_remove)):
    print(arr[i])
    del arr[i]
  return arr



print(sort_small_to_large([4, 5, 2, 3, 7, 7, "bob", 1, 8, "judy", 6, 10, "patrick", 9]))




# =====================================================================
